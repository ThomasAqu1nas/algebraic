use element::{ElementFinite, GroupOps};
use primitive_types::U256;

use crate::helpers::{gcd, U256Range};

use super::{
    operations::{Additive, BinaryOperation, BinaryOperationType, Multiplicative},
    properties::{Commutative, Finite, Identity},
    AlgebraicStructure,
};

pub mod element;
pub mod extension;
pub mod impls;

/// A trait representing a **group** under a binary operation `O`.
///
/// A group is an algebraic structure satisfying:
/// 1. Closure under a binary operation
/// 2. Associativity
/// 3. Identity element
/// 4. Inverse for every element
pub trait Group<O: BinaryOperationType>:
    std::fmt::Debug
    + Sized
    + AlgebraicStructure<O>
    + Identity<O, Self>
where
    Self::Element: GroupOps<O, Self>
{}

/// A trait for **finite groups**, which additionally provide information
/// about the **order** of individual elements (i.e., the smallest `n` such that `e^n = identity`).
pub trait FiniteGroup<O: BinaryOperationType>: Group<O> + Finite
where
    Self::Element: GroupOps<O, Self> + ElementFinite<O, Self>,
{
    /// Returns the order of the element `e` in the group.
    fn element_order(&self, e: &Self::Element) -> U256
    where
        Self::Element: ElementFinite<O, Self>,
    {
        <Self::Element as ElementFinite<O, Self>>::element_order(self, e)
    }
}

/// A trait representing an **abelian group** (also known as a **commutative group**),
/// where the binary operation is commutative: `a * b == b * a`.
pub trait AbelianGroup<O: BinaryOperationType>: Group<O>
where
    Self::Element: GroupOps<O, Self> + Commutative<O, Self>,
{}

/// Blanket implementation of `AbelianGroup` for any `Group<Additive>`
/// whose elements are also commutative under the additive operation.
impl<T: Group<Additive>> AbelianGroup<Additive> for T
where
    <T as AlgebraicStructure<Additive>>::Element: GroupOps<Additive, T>,
    <T as AlgebraicStructure<Additive>>::Element: Commutative<Additive, T>,
{}

/// Blanket implementation of `AbelianGroup` for any `Group<Multiplicative>`
/// whose elements are also commutative under the multiplicative operation.
impl<T: Group<Multiplicative>> AbelianGroup<Multiplicative> for T
where
    <T as AlgebraicStructure<Multiplicative>>::Element: GroupOps<Multiplicative, T>,
    <T as AlgebraicStructure<Multiplicative>>::Element: Commutative<Multiplicative, T>,
{}

/// A trait representing a **cyclic group** â€” a special type of finite abelian group
/// where all elements can be generated by repeated application of the operation
/// to a single **generator** element.
pub trait CyclingGroup<O: BinaryOperationType>: FiniteGroup<O> + AbelianGroup<O>
where
    Self::Element: GroupOps<O, Self> + ElementFinite<O, Self> + Commutative<O, Self>,
{
    /// Returns a generator element `g` such that every element in the group
    /// can be written as `g^k` for some integer `k`.
    fn generator(&self) -> Self::Element;

    /// Returns a list of all generators in the group.
    ///
    /// A value `g` is a generator if `gcd(k, order) == 1` for some exponent `k`.
    fn all_generators(&self) -> Vec<Self::Element> {
        let generator = self.generator();
        let order = self.order();

        let mut result = vec![];

        for k in U256Range::new(U256::one(), order) {
            if gcd(k, order) == U256::one() {
                let mut acc: Self::Element = Self::identity();
                for _ in U256Range::new(U256::zero(), k) {
                    acc = Self::Element::op(&acc, &generator);
                }
                result.push(acc);
            }
        }
        result
    }

    /// Checks whether the given element is a generator of the group.
    fn is_generator(&self, elem: &Self::Element) -> bool {
        let order = self.order();
        <Self::Element as ElementFinite<O, Self>>::element_order(self, elem) == order
    }
}
